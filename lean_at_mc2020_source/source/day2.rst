.. _day2:

***********************
Natural numbers in Lean
***********************

Today, we start manipulating natural numbers in Lean. Natural are defined as 

.. code:: lean 

  inductive ℕ : Type
  | 0 : ℕ
  | succ : ℕ → ℕ

This is saying that ``ℕ`` is the type "freely generated by" the rules:
  1. it contains ``0``, 
  2. for every inhabitant ``n : ℕ`` there is another inhabitant ``n.succ : ℕ``. 


The keyword ``inductive`` is telling Lean that ``ℕ`` supports **mathematical induction** (more on this on Day 4). 
This brings us to our first tactic about natural numbers.




Equality 
=========
Equality is a non-trivial thing in type theory. In math we use the equality symbol "=" to mean two different things 

.. math:: 

  \mathrm{let} \:\: x &= 5 \\
  (x+1)^2 &= x^2 + 2 x + 1

The first statement is simply assigning the value ``5`` to the variable ``x``. This is called *definitional equality* and in Lean this is denoted using ``:=``. We have already seen an example of when we learnt the ``have`` tactic.

You have already seen this in the ``have`` tactic. The second statement is in fact a *proposition* that requires a proof! This is called *propositional equality*. This is a much more complicated concept and we will see a lot of ways of proving this. After all, very statement in math is trying to prove some kind of equality!



Refl tactic 
============
For any element ``x``, we much have ``x = x``. This is indeed an **axiom** in type theory called **reflexivity**. We often invoke this axiom in math when we try to reduce the problem to showing "LHS = RHS". To invoke reflexivity we use the tactic ``refl,``

Note that ``refl`` can only be invoked when the "LHS" is *exactly* equal to "RHS" by (unfolding definitions if necessary) but even if you have to a very trivial manipulation to change "LHS" to "RHS" the ``refl`` tactic will fail.

.. code:: lean 

  example : (m n : ℕ) : m = m := 
  begin 
  sorry,
  end 

  example : (m n : ℕ) : m + n = m + n := 
  begin 
  sorry,
  end 

  example : (m n : ℕ) : m.succ = m.succ := 
  begin 
  sorry,
  end 

  example : (m n : ℕ) : m.succ.succ = m + 2:= 
  begin 
  sorry,
  end 

  example : (1 + 2) = (1 + 2) := 
  begin 
  sorry,
  end 

  example : (2 + 1) = (1 + 2) := 
  begin 
  sorry,
  end 

  example : (m n p : ℕ) : (m + n) + p = n + (m + p):= 
  begin 
  sorry,
  end 

Even though the last two statements look trivial, they are in fact theorems that need proofs. 
If you want to see how to prove these (and other fundamental theorems) using basic axioms of natural numbers, you should check out the `Natural Number Game`_. These theorems already exists in the `mathlib library`_ and we will focus on how to use them to prove more complicated math.

.. _`Natural Number Game`: https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/
.. _`mathlib library`: https://leanprover-community.github.io/mathlib_docs/




Norm_num tactic
----------------
The tactic ``norm_num`` is essentially a smart calculator. Whenever the proof involves just definitions and numbers the ``norm_num`` tactic will solve it for you. 

.. code:: lean 

  import tactic

  example : (1 + 2) = (1 + 2) := 
  begin 
    sorry,
  end 

  example : (2 + 1) = (1 + 2) := 
  begin 
    sorry,
  end 

  example : 2^32 - 1 = 3 * 5 * 17 * 257 * 65537 :=
  begin 
    sorry,
  end 

``norm_num`` can even do brute force checks like solving the following:

.. code:: lean 

  import tactic nat.prime 

  example : 65537 ∣ (2^32 - 1) :=
  begin 
    sorry,
  end 

  example : nat.prime 65537 :=
  begin 
    sorry,
  end 

But anything that does not involve explicit arithmetic/numerical calculation cannot be solved by ``norm_num``

.. code:: lean 

  import tactic 

  example (m n p : ℕ) : (m + n) + p = n + (m + p) := 
  begin 
    sorry,
  end

  example (n : ℕ) : n ∣ 2 * n := 
  begin 
    sorry,
  end

If you need to simplify an assumption, say ``hp : P``, then you need to use the tactic ``norm_num at hp``. ``norm_num at *`` will apply ``norm_num`` to each assumption and the goal.

.. code:: lean 

  import tactic 

  example (n : ℕ) (n = 2^32 - 1) : (n = 3 * 5 * 17 * 257 * 65537) :=
  begin 
    sorry,
  end



Rewrite tactic 
==============
The ``rw`` (rewrite) tactic is the Lean equivalent of mathematical phrases like 

* by Theorem ... 
* by equation ...
* by substituting ... in ...

``rw`` is also the main tactic we will invoke for using the `mathlib library`_.

.. .. table::
..   :widths: 40, 60

  +--------------------------+------------------------------------------------------------------------------------------+
  |``rw add_comm at g``      | search for the LHS of ``add_comm`` in the goal and replace it with the RHS               |
  +--------------------------+------------------------------------------------------------------------------------------+
  |``rw add_comm at g``      | search for the LHS of ``add_comm`` in the goal and replace it with the RHS               |
  +--------------------------+------------------------------------------------------------------------------------------+
  |gggg                      | target very specific ``add_comm`` occurrence .                                           |
  +--------------------------|                                                                                          |
  |``rw add_comm a _ at g``  |                                                                                          |
  +--------------------------|                                                                                          |
  |``rw add_comm _ b at g``  |                                                                                          |
  +--------------------------+------------------------------------------------------------------------------------------+


.. table::
  :widths: 30, 70

  +--------------------------+--------------------------------------------------------------------------------------------------------+
  |   ``rw add_comm``        | search for the LHS of ``add_comm`` in the goal and replace it with the RHS of ``add_comm``             |
  +--------------------------+--------------------------------------------------------------------------------------------------------+
  | ``rw add_comm a _``      | target a specific occurrence of ``add_comm``                                                           | 
  +--------------------------+                                                                                                        |
  | ``rw add_comm _ b``      |                                                                                                        |
  +--------------------------+                                                                                                        |
  | ``rw add_comm a b``      |                                                                                                        |
  +--------------------------+--------------------------------------------------------------------------------------------------------+
  |   ``rw add_comm at g``   | search for the LHS of ``add_comm`` in the assumption ``g`` and replace it with the RHS of ``add_comm`` |
  +--------------------------+--------------------------------------------------------------------------------------------------------+
  


Creating intermediate goals
============================
When writing a complicated proof you often have to create several intermediate "claims" or subgoals. 
This is done in Lean using the ``have`` tactic.

.. table::
  :widths: 30, 70

  +-----------------------+----------------------------------------------------------------------------+
  | ``have hf := f b c,`` | define ``a: f b c``                                                        |
  +-----------------------+----------------------------------------------------------------------------+
  | ``have hf : f b c,``  | Create two new problems:                                                   |
  |                       |                                                                            |
  |                       |  1. The first goal is to show ``a : f b c``                                |
  |                       |                                                                            |
  |                       |  2. The second goal is to show the original goal assuming ``a : f b c`` .  |
  +-----------------------+----------------------------------------------------------------------------+
  |                       |                                                                            |
  +-----------------------+----------------------------------------------------------------------------+

Simp tactic 
-----------



Set tactic 
-----------


Integers in Lean 
================


norm_cast tactic 
----------------




Exercises
================

Summing by induction
--------------------
You're going to end up with a goal state that has both nats and ints in it.
Use push_cast if you want to think about it as an int statement, and norm_cast if you want to think about it as a nat statement.
(Hint: the integers are a ring and the naturals are not.)
.. code:: lean 
   :name: summing_by_induction

    import tactic
    import data.int.basic

    -- by landing in ℤ, we avoid the perils of nat subtraction
    def f : ℕ → ℤ
    | 0 := 0
    | (n + 1) := n + f n

    example : f 1 = 1 := by refl

    #check nat.succ_eq_add_one
    example (n : ℕ) : 2 * f n = n * (n - 1) :=
    begin
      induction n with d hd, 
      -- n = 0 base case
      { sorry }, 
      -- inductive step
      sorry
    end




Meet interval_cases
-------------------

interval_cases can reduce the problem to check the cases c = 0 and c = 1. 

.. code:: lean 
   :name: interval_cases

    import tactic

    lemma one_lt_of_nontrivial_factor 
      {b c : ℕ} (hb : b < b * c) :
    1 < c :=
    begin
      contrapose! hb, 
      interval_cases c,
      sorry
    end




A number theory puzzle
----------------------
First, informally prove the following:
If p and q are consecutive primes, then p + q can be written as a product of three factors, each greater than 1.

Then, fill in the following formal sketch of the same theorem. 
We give two lemmas, together with an incomplete proof containing five ``sorry``. 
You can work on the lemmas and ``sorry`` in any order, without affecting the global structure of the proof.
If you like, you can tear down the provided sketch and make your own proof. 

In particular, feel free to solve the last one even if your proofs of the previous two have sorry

.. code-block:: lean
   :name: eq_2_of_even_prime

    import tactic
    import data.nat.prime
    import data.nat.parity

    example (p : ℕ) : p.prime → p = 2 ∨ p % 2 = 1 :=
    begin
      library_search,
    end

    #check @nat.prime.eq_two_or_odd
    lemma eq_2_of_even_prime {p : ℕ} (hp : nat.prime p) (h_even : nat.even p) : p = 2 :=
    begin
      sorry
    end

.. code-block:: lean
   :name: nontrivial_product_of_not_prime

    import tactic
    import data.nat.prime
    import data.nat.parity

    -- norm_num, linarith
    lemma nontrivial_product_of_not_prime
      {k : ℕ} (hk : ¬ k.prime) (two_le_k : 2 ≤ k) :
    ∃ a b < k, 1 < a ∧ 1 < b ∧ a * b = k :=
    begin
      have h1 := nat.exists_dvd_of_not_prime2 two_le_k hk,
      rcases h1 with ⟨a, ⟨b, hb⟩, ha1, ha2⟩,
      use [a, b], norm_num, 
      sorry
    end

.. code-block:: lean
   :name: nontrivial_product_of_not_prime_2

    import tactic
    import data.nat.prime
    import data.nat.parity

    lemma eq_2_of_even_prime {p : ℕ} (hp : nat.prime p) (h_even : nat.even p) : p = 2 := sorry

    lemma nontrivial_product_of_not_prime {k : ℕ} (hk : ¬ k.prime) (two_le_k : 2 ≤ k) :
    ∃ a b < k, 1 < a ∧ 1 < b ∧ a * b = k := sorry

    theorem three_fac_of_sum_consecutive_primes 
    {p q : ℕ} (hp : p.prime) (hq : q.prime) (hpq : p < q) 
    (p_ne_2 : p ≠ 2) (q_ne_2 : q ≠ 2)
    (consecutive : ∀ k, p < k → k < q → ¬ k.prime) :
    ∃ a b c, p + q = a * b * c ∧ a > 1 ∧ b > 1 ∧ c > 1 :=
    begin
      use 2, have h1 : nat.even (p + q), 
      { sorry },

      cases h1 with k hk, 
      have hk' : ¬ k.prime, 
      { sorry },

      have h2k : 2 ≤ k, 
      { sorry },

      have h2 := nat.exists_dvd_of_not_prime2 _ hk',
      swap, 
      { sorry },

      rcases nontrivial_product_of_not_prime hk' h2k with ⟨ b, c, hbk, hck, hb1, hc1, hbc⟩,
      use [b,c],
      { sorry },
    end