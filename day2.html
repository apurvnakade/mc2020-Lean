
<!DOCTYPE html>

<html>
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2. Logic in Lean - Part 2 &#8212; Lean at MC 2020 0.1 documentation</title>
    <link rel="stylesheet" href="static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
    <script src="static/jquery.js"></script>
    <script src="static/underscore.js"></script>
    <script src="static/doctools.js"></script>
    <script src="static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. Infinitely Many Primes" href="day3.html" />
    <link rel="prev" title="1. Logic in Lean - Part 1" href="day1.html" />
   
  <link rel="stylesheet" href="static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="logic-in-lean-part-2">
<span id="day2"></span><h1><span class="section-number">2. </span>Logic in Lean - Part 2<a class="headerlink" href="#logic-in-lean-part-2" title="Permalink to this headline">&#182;</a></h1>
<p>Your mission today is to wrap up the remaining bits of logic and move on to doing some &#8220;actual math&#8221;.
Remember to <strong>always save your work</strong>.
You might find the <a class="reference internal" href="tactics.html"><span class="doc">Glossary of tactics</span></a> page and the <a class="reference internal" href="symbols.html"><span class="doc">Pretty symbols</span></a> page useful.</p>
<p>Before we move on to new stuff, let&#8217;s understand what we did yesterday.</p>
<div class="section" id="behind-the-scenes">
<h2><span class="section-number">2.1. </span>Behind the scenes<a class="headerlink" href="#behind-the-scenes" title="Permalink to this headline">&#182;</a></h2>
<p><strong>A note on brackets:</strong>
It is not uncommon to compose half a dozen functions in Lean.
The brackets get really messy and unwieldy.
As such, Lean will often drop the brackets by following the following conventions.</p>
<ul class="simple">
<li><p>The function <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">Q</span> <span class="pre">&#8594;</span> <span class="pre">R</span> <span class="pre">&#8594;</span> <span class="pre">S</span></code> stands for <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">(Q</span> <span class="pre">&#8594;</span> <span class="pre">(R</span> <span class="pre">&#8594;</span> <span class="pre">S))</span></code>.</p></li>
<li><p>The expression <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">c</span> <span class="pre">+</span> <span class="pre">d</span></code> stands for <code class="docutils literal notranslate"><span class="pre">((a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">+</span> <span class="pre">c)</span> <span class="pre">+</span> <span class="pre">d</span></code>.</p></li>
</ul>
<p>An easy way to remember this is that, arrows are bracketed on the right and binary operators on the left.</p>
<div class="section" id="proof-irrelevance">
<h3><span class="section-number">2.1.1. </span>Proof irrelevance<a class="headerlink" href="#proof-irrelevance" title="Permalink to this headline">&#182;</a></h3>
<p>It might feel a bit weird to say that a proposition has proofs as its inhabitants.
Proofs can get huge and it seems unnecessary to have to remember not just the statement but also its proof.
This is something we don&#8217;t normally do in math.
To hide this complication, in type theory there is an axiom, called <em>proof irrelevance</em>, which says that
if <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">:</span> <span class="pre">Prop</span></code> and <code class="docutils literal notranslate"><span class="pre">hp1</span> <span class="pre">hp2</span> <span class="pre">:</span> <span class="pre">P</span></code> then <code class="docutils literal notranslate"><span class="pre">hp1</span> <span class="pre">=</span> <span class="pre">hp2</span></code>.
Taking our <em>analogy</em> with sets further, you can think of a proposition as a set which is either empty or contains a single element (false or true).
In fact, in some forms of type theory (e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/Homotopy_type_theory">homotopy type theory</a>) this is taken as the definition of propositions.
This is of course not true for general types.
For example, <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">&#8800;</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">&#8469;</span></code>.</p>
</div>
<div class="section" id="proofs-as-functions">
<h3><span class="section-number">2.1.2. </span>Proofs as functions<a class="headerlink" href="#proofs-as-functions" title="Permalink to this headline">&#182;</a></h3>
<p>Every time you successfully construct a proof of a theorem say</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>theorem tautology (P : Prop) : P &#8594; P :=
begin
  intro hp,
  exact hp,
end
</pre></div>
</div>
<p>Lean constructs a <em>proof term</em> <code class="docutils literal notranslate"><span class="pre">tautology</span> <span class="pre">:</span> <span class="pre">&#8704;</span> <span class="pre">P</span> <span class="pre">:</span> <span class="pre">Prop,</span> <span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">P</span></code>
(you can see this by typing <code class="docutils literal notranslate"><span class="pre">#check</span> <span class="pre">tautology</span></code>).</p>
<p>In type theory, the <em>for all</em> quantifier, <code class="docutils literal notranslate"><span class="pre">&#8704;</span></code>, is a generalized function, called a <a class="reference external" href="https://en.wikipedia.org/wiki/Dependent_type">dependent function</a>.
For all practical purposes, we can think of <code class="docutils literal notranslate"><span class="pre">tautology</span></code> as having the type <code class="docutils literal notranslate"><span class="pre">(P</span> <span class="pre">:</span> <span class="pre">Prop)</span> <span class="pre">&#8594;</span> <span class="pre">(P</span> <span class="pre">&#8594;</span> <span class="pre">P)</span></code>.
Note that this is not a function in the classical sense of the word because the codomain <code class="docutils literal notranslate"><span class="pre">(P</span> <span class="pre">&#8594;</span> <span class="pre">P)</span></code> <em>depends</em> on the input variable <code class="docutils literal notranslate"><span class="pre">P</span></code>.
If <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, then <code class="docutils literal notranslate"><span class="pre">tautology(Q)</span></code> is a term of type  <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">&#8594;</span> <span class="pre">Q</span></code>.</p>
<p>Consider a theorem with multiple hypothesis, say</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">theorem</span> <span class="n">hello_world</span> <span class="p">(</span><span class="n">hp</span> <span class="p">:</span> <span class="n">P</span><span class="p">)</span> <span class="p">(</span><span class="n">hq</span> <span class="p">:</span> <span class="n">Q</span><span class="p">)</span> <span class="p">(</span><span class="n">hr</span> <span class="p">:</span> <span class="n">R</span><span class="p">)</span> <span class="p">:</span> <span class="n">S</span>
</pre></div>
</div>
<p>Once we provide a proof of it, Lean will create a proof term
<code class="docutils literal notranslate"><span class="pre">hello_world</span> <span class="pre">:</span> <span class="pre">(hp:P)</span> <span class="pre">&#8594;</span> <span class="pre">(hq:Q)</span> <span class="pre">&#8594;</span> <span class="pre">(hr:R)</span> <span class="pre">&#8594;</span> <span class="pre">S</span></code>.
So that if we have terms <code class="docutils literal notranslate"><span class="pre">hp'</span> <span class="pre">:</span> <span class="pre">P</span></code>, <code class="docutils literal notranslate"><span class="pre">hq'</span> <span class="pre">:</span> <span class="pre">Q</span></code>, <code class="docutils literal notranslate"><span class="pre">hr'</span> <span class="pre">:</span> <span class="pre">R</span></code>
then <code class="docutils literal notranslate"><span class="pre">hello_world</span> <span class="pre">hp'</span> <span class="pre">hq'</span> <span class="pre">hr'</span></code> (note the convenient lack of brackets) will be a term of type <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
<p>Once constructed, any term can be used in a later proof. For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>example (P Q : Prop) : (P &#8594; Q) &#8594; (P &#8594; Q) :=
begin
  exact tautology (P &#8594; Q),
end
</pre></div>
</div>
<p>This is how Lean simulates mathematics.
Every time you prove a theorem using tactics a <em>proof term</em> gets created.
Because of proof irrelevance, Lean forgets the exact content of the proof and
only remembers its type.
All the proof terms can then be used in later proofs.
All of this falls under the giant umbrella of the <a class="reference external" href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry&#8211;Howard correspondence</a>.</p>
<p>We&#8217;ll now continue our study of the remaining logical operators: <em>and</em> (<code class="docutils literal notranslate"><span class="pre">&#8743;</span></code>),
<em>or</em> (<code class="docutils literal notranslate"><span class="pre">&#8744;</span></code>),
<em>if and only if</em> (<code class="docutils literal notranslate"><span class="pre">&#8596;</span></code>),
<em>for all</em> (<code class="docutils literal notranslate"><span class="pre">&#8704;</span></code>),
<em>there exists</em> (<code class="docutils literal notranslate"><span class="pre">&#8707;</span></code>).</p>
</div>
</div>
<div class="section" id="and-or">
<h2><span class="section-number">2.2. </span>And / Or<a class="headerlink" href="#and-or" title="Permalink to this headline">&#182;</a></h2>
<p>The operators <em>and</em> (<code class="docutils literal notranslate"><span class="pre">&#8743;</span></code>) and <em>or</em> (<code class="docutils literal notranslate"><span class="pre">&#8744;</span></code>) are very easy to use in Lean.
Given a term <code class="docutils literal notranslate"><span class="pre">hpq</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">&#8743;</span> <span class="pre">Q</span></code>,
there are tactics that let you
create terms <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">Q</span></code>, and vice versa.
Similarly for <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8744;</span> <span class="pre">Q</span></code>, with a subtle change (see below).</p>
<p><strong>Note</strong> that when multiple goals are open, you are trying to solve the topmost goal.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cases</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cases</span></code> is a general tactic that breaks a complicated term into simpler ones.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">hpq</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8743;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">hpq</span> <span class="pre">with</span> <span class="pre">hp</span> <span class="pre">hq,</span></code> breaks it into <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">Q</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">fg</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8596;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">fg</span> <span class="pre">with</span> <span class="pre">f</span> <span class="pre">g,</span></code> breaks it into <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">Q</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">:</span> <span class="pre">Q</span> <span class="pre">&#8594;</span> <span class="pre">P</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">hpq</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8744;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">hpq</span> <span class="pre">with</span> <span class="pre">hp</span> <span class="pre">hq,</span></code> creates two goals and adds the hypotheses <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">Q</span></code> to one each.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">split</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">split</span></code> is a general tactic that breaks a complicated goal into simpler ones.</p>
<p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8743;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">split,</span></code> breaks up the goal into two goals with targets <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#215;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">split,</span></code> breaks up the goal into two goals with targets <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8596;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">split,</span></code> breaks up the goal into two goals with targets <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">Q</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">&#8594;</span> <span class="pre">P</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">left</span></code></p></td>
<td><p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8744;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">left,</span></code> changes the target to <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">right</span></code></p></td>
<td><p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8744;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">right,</span></code> changes the target to <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p></td>
</tr>
</tbody>
</table>
<div id="and-or-example" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0A--%20these%20two%20statements%20tell%20Lean%20to%20use%20the%20law%20of%20excluded%20middle%20as%20necessary%0Anoncomputable%20theory%0Aopen_locale%20classical%0A%0A--BEGIN--%0A%0A%0A%2F--------------------------------------------------------------------------%0A%0A%60%60cases%60%60%0A%0A%20%20%60%60cases%60%60%20is%20a%20general%20tactic%20that%20breaks%20up%20complicated%20terms.%0A%20%20If%20%60%60hpq%60%60%20is%20a%20term%20of%20type%20%60%60P%20%E2%88%A7%20Q%60%60%20or%20%60%60P%20%E2%88%A8%20Q%60%60%20or%20%60%60P%20%E2%86%94%20Q%60%60%2C%20then%20use%0A%20%20%60%60cases%20hpq%20with%20hp%20hq%2C%60%60.%0A%0A%60%60split%60%60%0A%0A%20%20If%20the%20target%20of%20the%20current%20goal%20is%20%60%60P%20%E2%88%A7%20Q%60%60%20or%20%60%60P%20%E2%86%94%20Q%60%60%2C%20then%20use%0A%20%20%60%60split%2C%60%60.%0A%0A%60%60left%60%60%2F%60%60right%60%60%0A%0A%20%20If%20the%20target%20of%20the%20current%20goal%20is%20%60%60P%20%E2%88%A8%20Q%60%60%2C%20then%20use%0A%20%20either%20%60%60left%2C%60%60%20or%20%60%60right%2C%60%60%20(choose%20wisely).%0A%0A%60%60exfalso%60%60%0A%0A%20%20Changes%20the%20target%20of%20the%20current%20goal%20to%20%60%60false%60%60.%0A%0ADelete%20the%20%60%60sorry%2C%60%60%20below%20and%20replace%20them%20with%20a%20legitimate%20proof.%0A%0A--------------------------------------------------------------------------%2F%0A%0Aexample%20(P%20Q%20%3A%20Prop)%20%3A%20P%20%E2%88%A7%20Q%20%E2%86%92%20Q%20%E2%88%A7%20P%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Aexample%20(P%20Q%20%3A%20Prop)%20%3A%20P%20%E2%88%A8%20Q%20%E2%86%92%20Q%20%E2%88%A8%20P%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Aexample%20(P%20Q%20R%20%3A%20Prop)%20%3A%20P%20%E2%88%A7%20false%20%E2%86%94%20false%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Atheorem%20principle_of_explosion%20(P%20Q%20%3A%20Prop)%20%3A%20P%20%E2%88%A7%20%C2%AC%20P%20%E2%86%92%20Q%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0A--END--" id="and-or-example" target="_blank" tryitfile="../examples/day2/and_or_example.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span><span class="cm">-------------------------------------------------------------------------</span>

<span class="cm">``cases``</span>

<span class="cm">  ``cases`` is a general tactic that breaks up complicated terms.</span>
<span class="cm">  If ``hpq`` is a term of type ``P &#8743; Q`` or ``P &#8744; Q`` or ``P &#8596; Q``, then use</span>
<span class="cm">  ``cases hpq with hp hq,``.</span>

<span class="cm">``split``</span>

<span class="cm">  If the target of the current goal is ``P &#8743; Q`` or ``P &#8596; Q``, then use</span>
<span class="cm">  ``split,``.</span>

<span class="cm">``left``/``right``</span>

<span class="cm">  If the target of the current goal is ``P &#8744; Q``, then use</span>
<span class="cm">  either ``left,`` or ``right,`` (choose wisely).</span>

<span class="cm">``exfalso``</span>

<span class="cm">  Changes the target of the current goal to ``false``.</span>

<span class="cm">Delete the ``sorry,`` below and replace them with a legitimate proof.</span>

<span class="cm">--------------------------------------------------------------------------/</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">&#8743;</span> <span class="n">Q</span> <span class="bp">&#8594;</span> <span class="n">Q</span> <span class="bp">&#8743;</span> <span class="n">P</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">&#8744;</span> <span class="n">Q</span> <span class="bp">&#8594;</span> <span class="n">Q</span> <span class="bp">&#8744;</span> <span class="n">P</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">&#8743;</span> <span class="n">false</span> <span class="bp">&#8596;</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">principle_of_explosion</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="quantifiers">
<h2><span class="section-number">2.3. </span>Quantifiers<a class="headerlink" href="#quantifiers" title="Permalink to this headline">&#182;</a></h2>
<p>As mentioned it the introduction the <em>for all</em> quantifier, <code class="docutils literal notranslate"><span class="pre">&#8704;</span></code>, is a generalization of a function.
As such the tactics for dealing with <code class="docutils literal notranslate"><span class="pre">&#8704;</span></code> are the same as those for <code class="docutils literal notranslate"><span class="pre">&#8594;</span></code>.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">have</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">hp</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">X</span></code> then
<code class="docutils literal notranslate"><span class="pre">have</span> <span class="pre">hpy</span> <span class="pre">:=</span> <span class="pre">hp(y)</span></code> creates a hypothesis <code class="docutils literal notranslate"><span class="pre">hpy</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">y</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">intro</span></code></p></td>
<td><p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code>, then
<code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">x,</span></code> creates a hypothesis <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code> and
changes the target to <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">x</span></code>.</p></td>
</tr>
</tbody>
</table>
<p>The <em>there exists</em> quantifier, <code class="docutils literal notranslate"><span class="pre">&#8707;</span></code>, in type theory is very intuitive.
If you want to prove a statement <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code> then you need to provide a witness.
If you have a term <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code> then from this you can extract a witness.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cases</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">hp</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code>, then
<code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">hp</span> <span class="pre">with</span> <span class="pre">x</span> <span class="pre">key,</span></code> breaks it into
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">use</span></code></p></td>
<td><p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code>
and <code class="docutils literal notranslate"><span class="pre">y</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">X</span></code>, then
<code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">y,</span></code> changes the target to <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">y</span></code> and tries to close the goal.</p></td>
</tr>
</tbody>
</table>
<p>Finally, we know enough Lean tactics to start doing some fun stuff.</p>
<div class="section" id="barber-paradox">
<h3><span class="section-number">2.3.1. </span>Barber paradox<a class="headerlink" href="#barber-paradox" title="Permalink to this headline">&#182;</a></h3>
<p>Let&#8217;s disprove the &#8220;barber paradox&#8221; due to Bertrand Russell.
The claim is that in a certain town there is a (male) barber that shaves all the men who do not shave themselves. (Why is this a paradox?)
Prove that this is a contradiction.
Here are some <a class="reference internal" href="hint_1_barber_paradox.html"><span class="doc">hints</span></a> if you get stuck.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A--%20the%20next%20two%20lines%20let%20us%20use%20the%20by_cases%20tactic%20without%20trouble%0Anoncomputable%20theory%0Aopen_locale%20classical%0A%0A--BEGIN--%0A%0A%2F--------------------------------------------------------------------------%0A%0A%60%60by_cases%60%60%0A%0A%20%20If%20%60%60P%60%60%20is%20a%20proposition%2C%20then%20%60%60by_cases%20P%2C%60%60%20creates%20two%20goals%2C%0A%20%20%20%20the%20first%20with%20a%20hypothesis%20%60%60hp%3A%20P%60%60%20and%0A%20%20%20%20second%20with%20a%20hypothesis%20%60%60hp%3A%20%C2%AC%20P%60%60.%0A%0ADelete%20the%20%60%60sorry%2C%60%60%20below%20and%20replace%20them%20with%20a%20legitimate%20proof.%0A%0A--------------------------------------------------------------------------%2F%0A%0A--%20men%20is%20type.%0A--%20x%20%3A%20men%20means%20x%20is%20a%20man%20in%20the%20town%0A--%20shaves%20x%20y%20is%20inhabited%20if%20x%20shaves%20y%0A%0Avariables%20(men%20%3A%20Type)%20(barber%20%3A%20men)%0Avariable%20%20(shaves%20%3A%20men%20%E2%86%92%20men%20%E2%86%92%20Prop)%0A%0Aexample%20%3A%20%C2%AC%20(%E2%88%80%20x%20%3A%20men%2C%20shaves%20barber%20x%20%E2%86%94%20%C2%AC%20shaves%20x%20x)%20%3A%3D%0A%20%20begin%0A%20%20%20%20sorry%2C%0A%20%20end%0A--END--" target="_blank" tryitfile="../examples/day2/unnamed_252.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span><span class="cm">-------------------------------------------------------------------------</span>

<span class="cm">``by_cases``</span>

<span class="cm">  If ``P`` is a proposition, then ``by_cases P,`` creates two goals,</span>
<span class="cm">    the first with a hypothesis ``hp: P`` and</span>
<span class="cm">    second with a hypothesis ``hp: &#172; P``.</span>

<span class="cm">Delete the ``sorry,`` below and replace them with a legitimate proof.</span>

<span class="cm">--------------------------------------------------------------------------/</span>

<span class="c1">-- men is type.</span>
<span class="c1">-- x : men means x is a man in the town</span>
<span class="c1">-- shaves x y is inhabited if x shaves y</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">men</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">barber</span> <span class="o">:</span> <span class="n">men</span><span class="o">)</span>
<span class="kn">variable</span>  <span class="o">(</span><span class="n">shaves</span> <span class="o">:</span> <span class="n">men</span> <span class="bp">&#8594;</span> <span class="n">men</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">men</span><span class="o">,</span> <span class="n">shaves</span> <span class="n">barber</span> <span class="n">x</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span> <span class="n">shaves</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="kn">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="mathcampers-singing-paradox">
<h3><span class="section-number">2.3.2. </span>Mathcampers singing paradox<a class="headerlink" href="#mathcampers-singing-paradox" title="Permalink to this headline">&#182;</a></h3>
<p>Assume that the main lounge is non-empty.
At a fixed moment in time, there is someone in the lounge such that,
if they are singing,
then everyone in the lounge is singing.
(See <a class="reference internal" href="hint_1_mcsp.html"><span class="doc">hints</span></a>).</p>
<div id="lounge-paradox" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A--%20the%20next%20two%20lines%20let%20us%20use%20the%20by_cases%20tactic%20without%20trouble%0Anoncomputable%20theory%0Aopen_locale%20classical%0A%0A--BEGIN--%0A%0A%2F--------------------------------------------------------------------------%0A%0A%60%60by_cases%60%60%0A%0A%20%20If%20%60%60P%60%60%20is%20a%20proposition%2C%20then%20%60%60by_cases%20P%2C%60%60%20creates%20two%20goals%2C%0A%20%20%20%20the%20first%20with%20a%20hypothesis%20%60%60hp%3A%20P%60%60%20and%0A%20%20%20%20second%20with%20a%20hypothesis%20%60%60hp%3A%20%C2%AC%20P%60%60.%0A%0ADelete%20the%20%60%60sorry%2C%60%60%20below%20and%20replace%20them%20with%20a%20legitimate%20proof.%0A%0A--------------------------------------------------------------------------%2F%0A%0A--%20camper%20is%20a%20type.%0A--%20If%20x%20%3A%20camper%20then%20x%20is%20a%20camper%20in%20the%20main%20lounge.%0A--%20singing(x)%20is%20inhabited%20if%20x%20is%20singing%0A%0Atheorem%20math_campers_singing_paradox%0A%20%20(camper%20%3A%20Type)%0A%20%20(singing%20%3A%20camper%20%E2%86%92%20Prop)%0A%20%20(alice%20%3A%20camper)%20--%20making%20sure%20that%20there%20is%20at%20least%20one%20camper%20in%20the%20lounge%0A%20%20%3A%20%E2%88%83%20x%20%3A%20camper%2C%20(singing%20x%20%E2%86%92%20(%E2%88%80%20y%20%3A%20camper%2C%20singing%20y))%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A--END--" id="lounge-paradox" target="_blank" tryitfile="../examples/day2/lounge_paradox.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span><span class="cm">-------------------------------------------------------------------------</span>

<span class="cm">``by_cases``</span>

<span class="cm">  If ``P`` is a proposition, then ``by_cases P,`` creates two goals,</span>
<span class="cm">    the first with a hypothesis ``hp: P`` and</span>
<span class="cm">    second with a hypothesis ``hp: &#172; P``.</span>

<span class="cm">Delete the ``sorry,`` below and replace them with a legitimate proof.</span>

<span class="cm">--------------------------------------------------------------------------/</span>

<span class="c1">-- camper is a type.</span>
<span class="c1">-- If x : camper then x is a camper in the main lounge.</span>
<span class="c1">-- singing(x) is inhabited if x is singing</span>

<span class="kn">theorem</span> <span class="n">math_campers_singing_paradox</span>
  <span class="o">(</span><span class="n">camper</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">singing</span> <span class="o">:</span> <span class="n">camper</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">alice</span> <span class="o">:</span> <span class="n">camper</span><span class="o">)</span> <span class="c1">-- making sure that there is at least one camper in the lounge</span>
  <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">camper</span><span class="o">,</span> <span class="o">(</span><span class="n">singing</span> <span class="n">x</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="n">y</span> <span class="o">:</span> <span class="n">camper</span><span class="o">,</span> <span class="n">singing</span> <span class="n">y</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="relationship-conundrum">
<h3><span class="section-number">2.3.3. </span>Relationship conundrum<a class="headerlink" href="#relationship-conundrum" title="Permalink to this headline">&#182;</a></h3>
<p>A relation <code class="docutils literal notranslate"><span class="pre">r</span></code> on a type <code class="docutils literal notranslate"><span class="pre">X</span></code> is a map <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">Prop</span></code>.
We say that <code class="docutils literal notranslate"><span class="pre">x</span></code> is <em>related</em> to <code class="docutils literal notranslate"><span class="pre">y</span></code> if <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">x</span> <span class="pre">y</span></code> is inhabited.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> is reflexive if <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is related to itself.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> is symmetric if <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">:</span> <span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is related to <code class="docutils literal notranslate"><span class="pre">y</span></code> implies <code class="docutils literal notranslate"><span class="pre">y</span></code> is related to <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> is transitive if <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">:</span> <span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is related to <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> is related to <code class="docutils literal notranslate"><span class="pre">x</span></code> implies <code class="docutils literal notranslate"><span class="pre">z</span></code> is related to <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> is connected if for all <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code> there is a <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">:</span> <span class="pre">Y</span></code> such that <code class="docutils literal notranslate"><span class="pre">x</span></code> is related to <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p></li>
</ul>
<p>Show that if a relation is symmetric, transitive, and connected,
then it is also reflexive.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0Avariable%20X%20%3A%20Type%0A%0Atheorem%20reflexive_of_symmetric_transitive_and_connected%0A%20%20(r%20%3A%20X%20%E2%86%92%20X%20%E2%86%92%20Prop)%0A%20%20(h_symm%20%3A%20%E2%88%80%20x%20y%20%3A%20X%2C%20r%20x%20y%20%E2%86%92%20r%20y%20x)%0A%20%20(h_trans%20%3A%20%E2%88%80%20x%20y%20z%20%3A%20X%2C%20r%20x%20y%20%E2%86%92%20r%20y%20z%20%E2%86%92%20r%20x%20z)%0A%20%20(h_connected%20%3A%20%E2%88%80%20x%2C%20%E2%88%83%20y%2C%20r%20x%20y)%0A%3A%20(%E2%88%80%20x%20%3A%20X%2C%20r%20x%20x)%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend" target="_blank" tryitfile="../examples/day2/unnamed_345.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">variable</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kn">theorem</span> <span class="n">reflexive_of_symmetric_transitive_and_connected</span>
  <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_symm</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">&#8594;</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_trans</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">&#8594;</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">&#8594;</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_connected</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>
</div>
</div></div>
</div>
<div class="section" id="proving-trivial-statements">
<h2><span class="section-number">2.4. </span>Proving &#8220;trivial&#8221; statements<a class="headerlink" href="#proving-trivial-statements" title="Permalink to this headline">&#182;</a></h2>
<p>In mathlib, divisibility for natural numbers is defined as the following <em>proposition</em>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>a &#8739; b := (&#8707; k : &#8469;, a = b * k)
</pre></div>
</div>
<p>For example, <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">|</span> <span class="pre">4</span></code> will be a proposition <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">k</span> <span class="pre">:</span> <span class="pre">&#8469;,</span> <span class="pre">4</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">k</span></code>.
<strong>Very important.</strong> The statement <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">|</span> <span class="pre">4</span></code> is not saying that &#8220;2 divides 4 <em>is true</em>&#8221;.
It is simply a proposition that requires a proof.</p>
<p>Similarly, the mathlib library also contains the following definition of <code class="docutils literal notranslate"><span class="pre">prime</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>def nat.prime (p : &#8469;) : Prop
:=
  2 &#8804; p                                       -- p is at least 2
  &#8743;                                           -- and
  &#8704; (m : &#8469;), m &#8739; p &#8594; m = 1 &#8744; m = p            -- if m divides p, then m = 1 or m = p.
</pre></div>
</div>
<p>Same as with divisibility, for every natural number <code class="docutils literal notranslate"><span class="pre">n</span></code>,
<code class="docutils literal notranslate"><span class="pre">nat.prime</span> <span class="pre">n</span></code> is a <em>proposition</em>.
So that <code class="docutils literal notranslate"><span class="pre">nat.prime</span> <span class="pre">101</span></code> requires a proof.
It is possible to go down the rabbit hole and prove it using just the axioms of natural numbers.
However, this might come at the cost of your sanity.
Fortunately, there are tactics in Lean for proving trivial proofs such as these.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">norm_num</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">norm_num</span></code> is Lean&#8217;s calculator. If the target has a proof that involves <em>only</em> numbers and arithmetic operations,
then <code class="docutils literal notranslate"><span class="pre">norm_num</span></code> will close this goal.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> is an assumption then <code class="docutils literal notranslate"><span class="pre">norm_num</span> <span class="pre">at</span> <span class="pre">hp,</span></code> tries to use simplify <code class="docutils literal notranslate"><span class="pre">hp</span></code> using basic arithmetic operations.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ring</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ring,</span></code> is Lean&#8217;s symbolic manipulator.
If the target has a proof that involves <em>only</em> algebraic operations,
then <code class="docutils literal notranslate"><span class="pre">ring,</span></code> will close the goal.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> is an assumption then <code class="docutils literal notranslate"><span class="pre">ring</span> <span class="pre">at</span> <span class="pre">hp,</span></code> tries to use simplify <code class="docutils literal notranslate"><span class="pre">hp</span></code> using basic algebraic operations.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">linarith</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">linarith,</span></code> is Lean&#8217;s inequality solver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">simp</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">simp,</span></code> is a very complex tactic that tries to use theorems from the mathlib library to close the goal.
You should only ever use <code class="docutils literal notranslate"><span class="pre">simp,</span></code> to <em>close a goal</em> because its behavior changes as more theorems get added to the library.</p></td>
</tr>
</tbody>
</table>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%20data.nat.prime%0A%0A%2F--------------------------------------------------------------------------%0A%0A%60%60norm_num%60%60%0A%0A%20%20Useful%20for%20arithmetic.%0A%0A%60%60ring%60%60%0A%0A%20%20Useful%20for%20basic%20algebra.%0A%0A%60%60linarith%60%60%0A%0A%20%20Useful%20for%20inequalities.%0A%0A%60%60simp%60%60%0A%0A%20%20Complex%20simplifier.%20Use%20only%20to%20close%20goals.%0A%0ADelete%20the%20%60%60sorry%2C%60%60%20below%20and%20replace%20them%20with%20a%20legitimate%20proof.%0A%0A--------------------------------------------------------------------------%2F%0A%0Aexample%20%3A%201%20%3E%200%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Aexample%20(m%20a%20b%20%3A%20%E2%84%95)%20%3A%20%20m%5E2%20%2B%20(a%20%2B%20b)%20*%20m%20%2B%20a%20*%20b%20%3D%20(m%20%2B%20a)%20*%20(m%20%2B%20b)%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Aexample%20%3A%20101%20%E2%88%A3%202020%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0A%0A%23print%20nat.prime%0Aexample%20%3A%20nat.prime%20101%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0A--%20you%20will%20need%20the%20definition%0A--%20a%20%E2%88%A3%20b%20%3A%3D%20(%E2%88%83%20k%20%3A%20%E2%84%95%2C%20a%20%3D%20b%20*%20k)%0Aexample%20(m%20a%20b%20%3A%20%E2%84%95)%20%3A%20%20m%20%2B%20a%20%E2%88%A3%20m%5E2%20%2B%20(a%20%2B%20b)%20*%20m%20%2B%20a%20*%20b%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0A--%20try%20%60%60unfold%20nat.prime%20at%20hp%2C%60%60%20to%20get%20started%0Aexample%20(p%20%3A%20%E2%84%95)%20(hp%20%3A%20nat.prime%20p)%20%3A%20%C2%AC%20(p%20%3D%201)%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0A--%20if%20none%20of%20the%20simplifiers%20work%2C%20try%20doing%20%60%60contrapose!%60%60%0A--%20sometimes%20the%20simplifiers%20need%20a%20little%20help%0Aexample%20(n%20%3A%20%E2%84%95)%20%3A%200%20%3C%20n%20%E2%86%94%20n%20%E2%89%A0%200%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend" target="_blank" tryitfile="../examples/day2/unnamed_416.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span>import tactic data.nat.prime

/--------------------------------------------------------------------------

``norm_num``

  Useful for arithmetic.

``ring``

  Useful for basic algebra.

``linarith``

  Useful for inequalities.

``simp``

  Complex simplifier. Use only to close goals.

Delete the ``sorry,`` below and replace them with a legitimate proof.

--------------------------------------------------------------------------/

example : 1 &gt; 0 :=
begin
  sorry,
end

example (m a b : &#8469;) :  m^2 + (a + b) * m + a * b = (m + a) * (m + b) :=
begin
  sorry,
end

example : 101 &#8739; 2020 :=
begin
  sorry,
end


#print nat.prime
example : nat.prime 101 :=
begin
  sorry,
end

-- you will need the definition
-- a &#8739; b := (&#8707; k : &#8469;, a = b * k)
example (m a b : &#8469;) :  m + a &#8739; m^2 + (a + b) * m + a * b :=
begin
  sorry,
end

-- try ``unfold nat.prime at hp,`` to get started
example (p : &#8469;) (hp : nat.prime p) : &#172; (p = 1) :=
begin
  sorry,
end

-- if none of the simplifiers work, try doing ``contrapose!``
-- sometimes the simplifiers need a little help
example (n : &#8469;) : 0 &lt; n &#8596; n &#8800; 0 :=
begin
  sorry,
end
</pre></div>
</div>
</div></div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Lean at MC 2020</a></h1>








<!-- <h3>Navigation</h3> -->
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="day1.html">1. Logic in Lean - Part 1</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. Logic in Lean - Part 2</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#behind-the-scenes">2.1. Behind the scenes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#and-or">2.2. And / Or</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quantifiers">2.3. Quantifiers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#proving-trivial-statements">2.4. Proving &#8220;trivial&#8221; statements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="day3.html">3. Infinitely Many Primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="day4.html">4. Sqrt 2 is irrational</a></li>
<li class="toctree-l1"><a class="reference internal" href="day5.html">5. Bits &amp; Pieces</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="symbols.html">Pretty Symbols in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">Glossary of tactics</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="latex/lean_at_mc2020.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/lean-web-editor/">Lean Live Editor</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/mathlib_docs/">Lean Documentation</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/">Leanprover Community</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Apurva Nakade, Jalex Stark.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="sources/day2.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>